<?php namespace hws_base_tools;

function enable_comments_management()
{
    add_action('admin_head', 'hws_base_tools\custom_admin_menu_css');

}
function display_settings_comments_dashboard() { 
    // Perform the system check to get the report data
    $comments_system_report = perform_comments_system_check();
    $raw_report = $comments_system_report['raw_value']; ?>

    <!-- Comments Dashboard Panel -->
    <div class="panel">
        <h2 class="panel-title">Comments Reporting Dashboard</h2>
        <div class="panel-content">

            <!-- Comments Status Section -->
            <section style="margin-bottom: 20px;">
                <h3 style="margin-bottom: 10px;">WordPress Comments Overview</h3>
                <div style="padding-left: 20px;">
                    <?php
                    // Display the report generated by the system check
                    echo $raw_report;
                    ?>
                </div>
            </section>

            <!-- Link to WordPress Discussion Settings Page -->
            <section style="margin-bottom: 20px;">
                <h3>WordPress Discussion Settings</h3>
                <div style="padding-left: 20px;">
                    <a href="<?= esc_url(admin_url('options-discussion.php')) ?>" target="_blank" class="button button-primary">View Discussion Settings</a>
                </div>
            </section>

        </div>
    </div>
    <?php
}
function custom_admin_menu_css() {
    ?><style>
        /* Change the text color of the Comments menu in the admin dashboard */
        #menu-comments .wp-menu-name {
            color: red !important;
			            text-decoration: line-through !important;

        }
    </style><?php
}




function perform_comments_system_check() {
    write_log("Performing comments system check", false);

    // Check future comments and pingbacks status
    $future_comments_status = (get_option('default_comment_status') === 'closed') ? 'DISABLED' : 'ENABLED';
    $future_pingbacks_status = (get_option('default_ping_status') === 'closed') ? 'DISABLED' : 'ENABLED';
    
    // Check the status of prior comments and pingbacks (checking all posts)
    $prior_comments_disabled = true;
    $prior_pingbacks_disabled = true;
    $posts = get_posts([
        'post_status' => 'publish',
        'numberposts' => -1 // Fetch all posts
    ]);

    foreach ($posts as $post) {
        if ($post->comment_status !== 'closed') {
            $prior_comments_disabled = false;
        }
        if ($post->ping_status !== 'closed') {
            $prior_pingbacks_disabled = false;
        }
        if (!$prior_comments_disabled && !$prior_pingbacks_disabled) {
            break; // Stop checking once both are enabled
        }
    }

    // Merge future and prior status for comments
    $comments_status = ($prior_comments_disabled && $future_comments_status === 'DISABLED') ? 'DISABLED' : 'ENABLED';

    // Merge future and prior status for pingbacks
    $pingbacks_status = ($prior_pingbacks_disabled && $future_pingbacks_status === 'DISABLED') ? 'DISABLED' : 'ENABLED';

    // Check if users must be registered to comment
    $users_must_be_registered = check_users_must_be_registered_to_comment() ? 'REQUIRED' : 'NOT REQUIRED';

    // Check if comments are allowed on new posts
    $comments_allowed_on_new_posts = (get_option('default_comment_status') === 'open') ? 'ALLOWED' : 'NOT ALLOWED';

    // Get comment counts
    $pending_comments = get_comments(['status' => 'hold', 'count' => true]);
    $spam_comments = get_comments(['status' => 'spam', 'count' => true]);
    $total_comments = wp_count_comments()->total_comments;

    // Determine overall status
    $overall_status = ($comments_status === 'DISABLED' && $pingbacks_status === 'DISABLED') ? 'true' : 'false';

    // Generate the report
    $report = "<br />-----<br /><strong>Comments Status (prior and future):</strong> " . ($comments_status === 'DISABLED' 
        ? "<span>DISABLED</span><br>" 
        : "<span style='color:red;'>ENABLED</span><br>");
    $report .= ($comments_status === 'DISABLED'
        ? "<button class='button execute-function block' data-method='toggle_wordpress_comments' data-state='enable' data-loader='true'>Enable Comments</button><br>"
        : "<button class='button execute-function block' data-method='toggle_wordpress_comments' data-state='disable' data-loader='true'>Disable Comments</button><br>");

    // Pingbacks Status
    $report .= "<strong>Pingbacks Status (prior and future):</strong> " . ($pingbacks_status === 'DISABLED'
        ? "<span>DISABLED</span><br>"
        : "<span style='color:red;'>ENABLED</span><br>");
    $report .= ($pingbacks_status === 'DISABLED'
        ? "<button class='button execute-function block' data-method='toggle_wordpress_pingbacks' data-state='enable' data-loader='true'>Enable Pingbacks</button><br>"
        : "<button class='button execute-function block' data-method='toggle_wordpress_pingbacks' data-state='disable' data-loader='true'>Disable Pingbacks</button><br>");

    // User registration requirement
    $report .= "<strong>Users Must Be Registered to Comment:</strong> " . ($users_must_be_registered === 'REQUIRED'
        ? "<span>REQUIRED</span><br>"
        : "<span style='color:red;'>NOT REQUIRED</span><br>");
    $report .= ($users_must_be_registered === 'REQUIRED'
        ? "<button class='button execute-function block' data-method='toggle_user_registration_requirement' data-state='disable' data-loader='true'>Disable User Registration Requirement</button><br>"
        : "<button class='button execute-function block' data-method='toggle_user_registration_requirement' data-state='enable' data-loader='true'>Require User Registration to Comment</button><br>");

    // Allow comments on new posts
    $report .= "<strong>Allow People to Submit Comments on New Posts:</strong> " . ($comments_allowed_on_new_posts === 'ALLOWED'
        ? "<span style='color:red;'>ALLOWED</span><br>"
        : "<span>NOT ALLOWED</span><br>");
    $report .= ($comments_allowed_on_new_posts === 'ALLOWED'
        ? "<button class='button execute-function block' data-method='toggle_comments_allowed_on_new_posts' data-state='disable' data-loader='true'>Disallow Comments on New Posts</button><br>"
        : "<button class='button execute-function block' data-method='toggle_comments_allowed_on_new_posts' data-state='enable' data-loader='true'>Allow Comments on New Posts</button><br>");

    // Comment Support Functionality
    /*
    not working, neither sure if this is needed. 
    $report .= "<br /><strong>Comment Support Functionality:</strong><br>";
    $report .= get_comment_support_status();
    $report .= "<button class='button execute-function block' data-method='toggle_comment_support' data-loader='true'>Toggle Comment Support</button><br>";

    // Pingback Support Functionality
    $report .= "<br /><strong>Pingback Support Functionality:</strong><br>";
    $report .= get_pingback_support_status();
    $report .= "<button class='button execute-function block' data-method='toggle_pingback_support' data-loader='true'>Toggle Pingback Support</button><br>";
*/

     // Add pending and spam comment sections with delete buttons
     $report .= "<strong>Pending Comments:</strong> " . ($pending_comments > 0 
     ? "<span style='color:red;'>$pending_comments</span>
        <button class='button execute-function block' data-method='delete_pending_comments' data-loader='true'>Delete Pending Comments</button><br>"
     : "$pending_comments (none)<br>");
 $report .= "<strong>Spam Comments:</strong> " . ($spam_comments > 0
     ? "<span style='color:red;'>$spam_comments</span>
        <button class='button execute-function block' data-method='delete_spam_comments' data-loader='true'>Delete Spam Comments</button><br>"
     : "$spam_comments (none)<br>");

 // Add total comments section
 $report .= "<strong>Total Comments:</strong> $total_comments<br>-----";
 $report .= ($total_comments > 0
 ? "<span>$total_comments</span>
    <button class='button execute-function block' data-method='delete_all_comments' data-loader='true'>Delete All Comments</button><br>"
 : "$total_comments (none)<br>");



    // Log and return the final report
    write_log(strip_tags($report), false);
    return [
        'function' => 'perform_comments_system_check',
        'status' => $overall_status,
        'raw_value' => $report,
        'variables' => [
            'comments_status' => $comments_status,
            'pingbacks_status' => $pingbacks_status,
            'users_must_be_registered' => $users_must_be_registered,
            'comments_allowed_on_new_posts' => $comments_allowed_on_new_posts,
            'pending_comments' => $pending_comments,
            'spam_comments' => $spam_comments,
            'total_comments' => $total_comments
        ]
    ];
}

function get_comment_support_status() {
    $post_types = get_post_types();
    $all_disabled = true; // Assume all post types have comments disabled initially

    write_log("Checking comment support status for post types: " . implode(", ", $post_types), true); // Log all post types

    foreach ($post_types as $post_type) {
        if (post_type_supports($post_type, 'comments')) {
            // Log which post type has comment support enabled
            write_log("xxx: Comments are enabled for post type: " . $post_type, true);

            // Return "ENABLED" as soon as we find one post type that supports comments
            return "<span style='color:red;'>ENABLED</span><br>";
        } else {
            // Log if comment support is not enabled for this post type
            write_log("xxx: Comments are disabled for post type: " . $post_type, true);
        }
    }

    // If we loop through all post types and none support comments, return "DISABLED"
    write_log("No post types have comments enabled.", true);
    return "<span>DISABLED</span><br>";
}




function toggle_comment_support() {
    $post_types = get_post_types(['public' => true]); // Filter only public post types
    write_log("Post types: " . implode(", ", $post_types), true);  // Log relevant post types

    // Get current status from options table
    $comments_enabled = get_option('comment_support_enabled', true);

    // Now toggle the support for comments based on the current state
    if ($comments_enabled) {
        foreach ($post_types as $post_type) {
            write_log("Removing comments support from: " . $post_type, true);
            remove_post_type_support($post_type, 'comments');
        }
        update_option('comment_support_enabled', false); // Save the state
        wp_cache_flush(); // Clear cache to apply changes
        return "Comments have been disabled for all public post types.";
    } else {
        foreach ($post_types as $post_type) {
            write_log("Adding comments support to: " . $post_type, true);
            add_post_type_support($post_type, 'comments');
        }
        update_option('comment_support_enabled', true); // Save the state
        wp_cache_flush(); // Clear cache to apply changes
        return "Comments have been enabled for all public post types.";
    }
}








function get_pingback_support_status() {
    $post_types = get_post_types();
    $all_disabled = true;

    foreach ($post_types as $post_type) {
        if (post_type_supports($post_type, 'trackbacks')) {
            $all_disabled = false;
            break;  // Stop as soon as one post type supports it
        }
    }

    if ($all_disabled) {
        return "<span>DISABLED</span><br>";
    } else {
        return "<span style='color:red;'>ENABLED</span><br>";
    }
}

// Toggle support for pingbacks for all post types
function toggle_pingback_support() {
    $post_types = get_post_types();
    foreach ($post_types as $post_type) {
        if (post_type_supports($post_type, 'trackbacks')) {
            remove_post_type_support($post_type, 'trackbacks');
        } else {
            add_post_type_support($post_type, 'trackbacks');
        }
    }
}

if (!function_exists('check_users_must_be_registered_to_comment')) {
    function check_users_must_be_registered_to_comment() {
        return get_option('comment_registration') ? true : false;
    }
} else write_log("Warning: check_users_must_be_registered_to_comment function is already declared", true);

if (!function_exists('toggle_user_registration_requirement')) {
    function toggle_user_registration_requirement($state) {
        $new_value = ($state === 'enable') ? 1 : 0;
        update_option('comment_registration', $new_value);
        return true;
    }
} else write_log("Warning: toggle_user_registration_requirement function is already declared", true);

if (!function_exists('toggle_comments_allowed_on_new_posts')) {
    function toggle_comments_allowed_on_new_posts($state) {
        $new_value = ($state === 'enable') ? 'open' : 'closed';
        update_option('default_comment_status', $new_value);
        return true;
    }
} else write_log("Warning: toggle_comments_allowed_on_new_posts function is already declared", true);







// Function to delete pending comments
if (!function_exists('hws_base_tools\delete_pending_comments')) {
    function delete_pending_comments() {
        $pending_comments = get_comments(['status' => 'hold']);
        foreach ($pending_comments as $comment) {
            wp_delete_comment($comment->comment_ID, true);
        }
        
        // Check if all pending comments are deleted
        $remaining_pending = get_comments(['status' => 'hold', 'count' => true]);
        $status = $remaining_pending > 0 ? false : true;
        $raw_value = $status ? 'true' : 'false';

        return [
            'function' => 'delete_pending_comments',
            'status' => $status,
            'raw_value' => $raw_value
        ];
    }
} else write_log("Warning: delete_pending_comments function is already declared", true);


// Function to delete spam comments
if (!function_exists('hws_base_tools\delete_spam_comments')) {
    function delete_spam_comments() {
        $spam_comments = get_comments(['status' => 'spam']);
        foreach ($spam_comments as $comment) {
            wp_delete_comment($comment->comment_ID, true);
        }

        // Check if all spam comments are deleted
        $remaining_spam = get_comments(['status' => 'spam', 'count' => true]);
        $status = $remaining_spam > 0 ? false : true;
        $raw_value = $status ? 'true' : 'false';

        return [
            'function' => 'delete_spam_comments',
            'status' => $status,
            'raw_value' => $raw_value
        ];
    }
} else write_log("Warning: delete_spam_comments function is already declared", true);


// Function to delete all comments
if (!function_exists('hws_base_tools\delete_all_comments')) {
    function delete_all_comments() {
        $all_comments = get_comments(['status' => 'all']);
        foreach ($all_comments as $comment) {
            wp_delete_comment($comment->comment_ID, true);
        }

        // Check if all comments are deleted
        $remaining_comments = wp_count_comments()->total_comments;
        $status = $remaining_comments > 0 ? false : true;
        $raw_value = $status ? 'true' : 'false';

        return [
            'function' => 'delete_all_comments',
            'status' => $status,
            'raw_value' => $raw_value
        ];
    }
} else write_log("Warning: delete_all_comments function is already declared", true);




if (!function_exists('hws_base_tools\toggle_wordpress_comments')) {
    function toggle_wordpress_comments($state) {
        if (!is_string($state)) {
            write_log("Invalid state type passed: Expected string, received " . gettype($state), true);
            return false;
        }

        write_log("Entered toggle_wordpress_comments with state: $state", true);

        // Determine the comment status based on the state
        $comment_status = ($state === 'enable') ? 'open' : 'closed';

        // Update the option for default comment status for future posts
        update_option('default_comment_status', $comment_status);
        write_log("Updated default_comment_status to: " . get_option('default_comment_status'), true);

        // Toggle comments for prior posts
        $posts = get_posts([
            'post_status' => 'publish',
            'numberposts' => -1
        ]);

        write_log("Found " . count($posts) . " posts to update for comments.", true);

        if (!empty($posts)) {
            foreach ($posts as $post) {
                wp_update_post([
                    'ID' => $post->ID,
                    'comment_status' => $comment_status
                ]);
                write_log("Updated post ID {$post->ID} with comment_status: $comment_status", true);
            }
            write_log("Comments successfully {$state}d on prior posts.", true);
        } else {
            write_log("No published posts found to {$state} comments.", true);
        }

        return true; // Return true to indicate success
    }
} else {
    write_log("Warning: toggle_wordpress_comments function is already declared", true);
}

if (!function_exists('hws_base_tools\toggle_wordpress_pingbacks')) {
    function toggle_wordpress_pingbacks($state) {
        if (!is_string($state)) {
            write_log("Invalid state type passed: Expected string, received " . gettype($state), true);
            return false;
        }

        write_log("Entered toggle_wordpress_pingbacks with state: $state", true);

        // Determine the pingback status based on the state
        $ping_status = ($state === 'enable') ? 'open' : 'closed';

        // Update the option for default ping status for future posts
        update_option('default_ping_status', $ping_status);
        write_log("Updated default_ping_status to: " . get_option('default_ping_status'), true);

        // Toggle pingbacks for prior posts
        $posts = get_posts([
            'post_status' => 'publish',
            'numberposts' => -1
        ]);

        write_log("Found " . count($posts) . " posts to update for pingbacks.", true);

        if (!empty($posts)) {
            foreach ($posts as $post) {
                wp_update_post([
                    'ID' => $post->ID,
                    'ping_status' => $ping_status
                ]);
                write_log("Updated post ID {$post->ID} with ping_status: $ping_status", true);
            }
            write_log("Pingbacks successfully {$state}d on prior posts.", true);
        } else {
            write_log("No published posts found to {$state} pingbacks.", true);
        }

        return true; // Return true to indicate success
    }
} else {
    write_log("Warning: toggle_wordpress_pingbacks function is already declared", true);
}

